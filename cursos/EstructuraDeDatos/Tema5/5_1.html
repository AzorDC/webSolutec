<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tema 5.1</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog Template">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">
    <link rel="shortcut icon" href="../../../solutec.ico">

    <!-- FontAwesome JS-->
    <script defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="../../../assets/css/theme-7.css">

</head>

<body>

    <header>
        <nav class="navbar navbar-dark">
            <a href="../../../index.html"> <img src="../../../assets/images/solutec.png" alt="SoluTec" class="logo-navbar"> </a>
            <div class="navbar-item">
                <a href="../../../index.html" class="nav-link">
                    <h6 class="list-group-item">Home</h6>
                </a>
                <a href="../../../blog-list.html" class="nav-link">
                    <h6 class="list-group-item">Cursos</h6>
                </a>
                <a href="#" class="nav-link">
                    <h6 class="list-group-item">Sobre nosotros</h6>
                </a>
            </div>
        </nav>
    </header>

    <div class="header">
        <h3 class="text-center text-white titulo-indice">ÍNDICE</h3>
        <ol class="temas">
            <!-- TEMA 1 -->
            <li class="tema">
                <a href="./1_1.html" class="tema-indice">
					Introducción a las estructuras de datos.
				</a>

                <!-- SUBTEMAS-->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema1/1_1.html" class="tema-indice">
							1.1. Clasificacion de las estructuras de datos.
						</a>
                    </li>
                    <li>
                        <a href="../Tema1/1_2.html" class="tema-indice">
							1.2. Tipos de datos abstractos (TDA).
						</a>
                    </li>
                    <li>
                        <a href="../Tema1/1_3.html" class="tema-indice">
							1.3. Ejemplos de TDA´s
						</a>
                    </li>
                    <li>
                        <a href="../Tema1/1_4.html" class="tema-indice">
							1.4. Manejo de memoria.
						</a>
                    </li>
                    <li>
                        <a href="../Tema1/1_5.html" class="tema-indice">
							1.5. Analisis de algoritmos.
						</a>
                    </li>                   
                </ul>
            </li>

            <!-- TEMA 2 -->
            <li class="tema">
                <a href="../Tema2/2_1.html" class="tema-indice"> Pilas </a>

                <!-- SUBTEMAS -->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema2/2_1.html" class="tema-indice">
							2.1. ¿Qué es una pila?.
						</a>
                    </li>
                    <li>
                        <a href="../Tema2/2_2.html" class="tema-indice">
                            2.2. Para que nos puede servir una pila.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema2/2_3.html" class="tema-indice">
                            2.3. Teoria de una Pila.
                        </a>
                    </li>
                    <li>
                        <a href="#" class="tema-indice">2.4. Implementacion de una pila a nivel codigo.</a>
                    </li>
                </ul>
            </li>

            <!-- TEMA 3 -->
            <li class="tema">
                <a href="#" class="tema-indice">Colas</a>

                <!-- SUBTEMAS -->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema3/3_1.html" class="tema-indice">
                            3.1. ¿Qué es una Cola?.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema3/3_2.html" class="tema-indice">
                            3.2. Para que nos puede servir una Cola.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema3/3_3.html" class="tema-indice">
                            3.3. Teoria de una Cola.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema3/3_4.html" class="tema-indice">
                            3.4. Implementación de una Cola a nivel código.
                        </a>
                    </li>
                </ul>
            </li>

            <!-- TEMA 4 -->
            <li class="tema">
                <a href="#" class="tema-indice">Listas</a>

                <!-- SUBTEMAS -->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema4/4_1.html" class="tema-indice">
                            4.1. ¿Qué es una Lista?.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema4/4_2.html" class="tema-indice">
                            4.2. Para que nos puede servir una Lista.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema4/4_3.html" class="tema-indice">
                            4.3. Teoría de una Lista.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema4/4_4.html" class="tema-indice">
                            4.4. Implementación de una Lista a nivel código.
                        </a>
                    </li>
                </ul>
            </li>

            <!-- TEMA 5 -->
            <li class="tema">
                <a href="#" class="tema-indice">Métodos de Ordenamientos</a>

                <!-- SUBTEMAS -->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema5/5_1.html" class="tema-indice">
                            5.1. Algoritmos de ordenamiento internos.
                        </a>
                    </li>                    
                </ul>
            </li>
            <!-- TEMA 6 -->
            <li class="tema">
                <a href="#" class="tema-indice">Recursividad</a>

                <!-- SUBTEMAS -->
                <ul class="lista-subtema">
                    <li>
                        <a href="../Tema6/6_1.html" class="tema-indice">
                            6.1. Definición.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema6/6_2.html" class="tema-indice">
                            6.2. Procedimientos recursivos.
                        </a>
                    </li>
                    <li>
                        <a href="../Tema6/6_3.html" class="tema-indice">
                            6.3. Ejemplos de casos recursivos.
                        </a>
                    </li>                    
                </ul>
            </li>
        </ol>
    </div>

    <div class="main-wrapper">

        <article class="blog-post px-3 py-5 p-md-5">
            <div class="container">
                <header class="blog-post-header">
                    <h2 class="title mb-2">5.1. Algoritmos de ordenamiento internos.</h2>
                    <div class="meta mb-3"><span class="date">05 de noviembre de 2021</span></div>
                </header>

                <p>
                    Ordenamiento: Es el acomodar ya sea de forma descendente o ascendente los datos, ya sea de una Lista o de un archivo.
                </p>
                <p>
                    A continuación mencionaremos los diferentes métodos para ordenar:
                </p>
                <ol>
			         <li>Burbuja (Simple, Mejorada y Optimizada)</li>
			         <li>ShellSort</li>                   
                     <li>RadixSort (Sorteo de Raíz)</li>
                     <li>QuickSort (Sorteo Rápido)</li>
		        </ol> 
                <p>
                   Los algoritmos de ordenamiento se pueden clasificar de las siguientes maneras: 
                </p>                              
                <p>
                    La más común es clasificar según el lugar donde se realice la ordenación
                </p>
                <ul>
                    <li><b>Algoritmos de ordenamiento interno</b> En la memoria del ordenador.</li>
                    <li><b>Algoritmos de ordenamiento externo</b> En un lugar externo como un disco duro.</li>                                        
		        </ul> 
                <p>
                    Por el tiempo que tardan en realizar la ordenación, dadas entradas ya ordenadas o inversamente ordenadas:
                </p>
                <ul>
			         <li><b>Algoritmos de ordenación natural</b> Tarda lo mínimo posible cuando la entrada está ordenada.</li>
			         <li><b>Algoritmos de ordenación no natural</b> Tarda lo mínimo posible cuando la entrada está inversamente ordenada.</li> 
                     <li><b>Por estabilidad</b> un ordenamiento estable mantiene el orden relativo que tenían originalmente los elementos con claves iguales. Por ejemplo, si una lista ordenada por fecha se reordena en orden alfabético con un algoritmo estable, todos los elementos cuya clave alfabética sea la misma quedarán en orden de fecha. Otro caso sería cuando no interesan las mayúsculas y minúsculas, pero se quiere que si una clave aBC estaba antes que AbC, en el resultado ambas claves aparezcan juntas y en el orden original: aBC, AbC.</li> 
		        </ul> 
                <p>
                   Cuando los elementos son indistinguibles (porque cada elemento se ordena por la clave completa) la estabilidad no interesa. Los algoritmos de ordenamiento que no son estables se pueden implementar para que sí lo sean. Una manera de hacer esto es modificar artificialmente la clave de ordenamiento de modo que la posición original en la lista participe del ordenamiento en caso de coincidencia.
                </p>                
                <h3 class="mt-5 mb-3">Metodo Burbuja</h3>                
                <p>
                   El método de burbuja también se le puede llamar como Método de "intercambio directo". El algoritmo ordena los elementos del arreglo utilizando el método de la burbuja. Transporta en cada pasada el elemento más pequeño hacia la parte de izquierda del arreglo. Este ordenamiento es eficiente sólo en listas pequeñas (10 elementos).El método de burbuja va comparando cada elemento del arreglo con el siguiente; si un elemento es mayor que el que le sigue, entonces se intercambian; esto producirá que en el arreglo quede como su último elemento, el más grande. Este proceso deberá repetirse recorriendo todo el arreglo hasta que no ocurra ningún intercambio. Los elementos que van quedando ordenados ya no se comparan. “Baja el más pesado”. Esté método se basa en el principio de comparar pares de elementos adyacentes intercambiarlos entre sí hasta que estén todos ordenados.
                </p>
                <img src="../resources/img5.1-1.PNG" alt="img1" class="img-fluid">
                <p>
                </p>
                <p>
                   El método de la burbuja es una comparación lineal con cada uno de los elementos, el elemento que sea menor contra el que se está comparado intercambiaran posiciones. Este método no es recomendado para grandes comparaciones, ya que es un proceso muy lento y requiere de una gran cantidad de Memoria RAM.
                </p>                    
                <h3 class="mt-5 mb-3">Metodo QuickSort</h3>                                 
                <p>
                   El ordenamiento rápido (quicksort en inglés) es un algoritmo creado por el científico británico en computación C. A. R. Hoare basado en la técnica de divide y vencerás, que permite, en promedio, ordenar n elementos en un tiempo proporcional a n log n.

                </p>
                <p>
                   El algoritmo trabaja de la siguiente forma:
                </p>
                <ol>
			         <li>Elegir un elemento de la lista de elementos a ordenar, al que llamaremos pivote.</li>
			         <li>Resituar los demás elementos de la lista a cada lado del pivote, de manera que a un lado queden todos los menores que él, y al otro los mayores. Los elementos iguales al pivote pueden ser colocados tanto a su derecha como a su izquierda, dependiendo de la implementación deseada. En este momento, el pivote ocupa exactamente el lugar que le corresponderá en la lista ordenada.</li> 
                     <li>La lista queda separada en dos sublistas, una formada por los elementos a la izquierda del pivote, y otra por los elementos a su derecha.</li> 
                    <li>Repetir este proceso de forma recursiva para cada sublista mientras éstas contengan más de un elemento. Una vez terminado este proceso todos los elementos estarán ordenados.</li>
		        </ol> 
                <p>
                   Como se puede suponer, la eficiencia del algoritmo depende de la posición en la que termine el pivote elegido.
                </p>                           
                <ol>
			         <li>En el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es O(n•log n).</li>
			         <li>En el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de O(n²). El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas. Pero principalmente depende del pivote, si por ejemplo el algoritmo implementado toma como pivote siempre el primer elemento del array, y el array que le pasamos está ordenado, siempre va a generar a su izquierda un array vacío, lo que es ineficiente.</li>  
		        </ol> 
                <h3 class="mt-5 mb-3">Pseudocodigo usando quick sort</h3>  
                <img src="../resources/img5.1-2.PNG" alt="img1" class="img-fluid">
                <nav class="blog-nav nav nav-justified my-5">
                    <a class="nav-link-prev nav-item nav-link rounded-left" href="../Tema4/4_4.html">Anterior<i class="arrow-prev fas fa-long-arrow-alt-left"></i></a>
                    <a class="nav-link-next nav-item nav-link rounded-right" href="../Tema6/6_1.html">Siguiente<i class="arrow-next fas fa-long-arrow-alt-right"></i></a>
                </nav>
            </div>
        </article>


        <footer class="footer text-center py-2 theme-bg-dark">

            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can buy the commercial license via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Designed with <i class="fas fa-heart" style="color: #fb866a;"></i> by <a href="http://themes.3rdwavemedia.com" target="_blank">Xiaoying Riley</a> for developers</small>

        </footer>

    </div>

    <!-- Javascript -->
    <script src="assets/plugins/jquery-3.3.1.min.js"></script>
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

</body>